# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

# Check this for cherry picking Vanilla: https://github.com/honza/vim-snippets/blob/master/snippets/javascript/javascript.snippets
# Check this for cherry picking Node: https://github.com/honza/vim-snippets/blob/master/snippets/javascript/javascript.node.snippets

# Vanilla
# -------

# Functions
snippet proto "Prototype method"
${1:className}.prototype.${2:methodName} = function(${3:params}) {
	${0:${VISUAL}}
};
endsnippet

snippet fun "Function"
function ${1:functionName}(${2:params}) {
	${0:${VISUAL}}
}
endsnippet

snippet asfun "Async function"
async function ${1:functionName}(${2:params}) {
	${0:${VISUAL}}
}
endsnippet

snippet funexp "Function assigned to variable"
var ${1:functionName} = function $1(${2:params}) {
	${0:${VISUAL}}
};
endsnippet

snippet iife "IIFE"
(function ${1:functionName}(${2:params}) {
	${0:${VISUAL}}
}(${3:args}));
endsnippet

# Flow control
snippet if "if (condition) { ... }"
if (${1:true}) {
	${0:${VISUAL}}
}
endsnippet

snippet ifelse "if (condition) { ... } else { ... }"
if (${1:true}) {
	${0:${VISUAL}}
} else {
	${2}
}
endsnippet

snippet ternary "Ternary: `condition ? true : false`"
$1 ? $2: $0
endsnippet

snippet switch
switch (${1:expression}) {
	case '${3:case}':
		${4}
		break;
		${0}
	default:
		${2}
}
endsnippet

snippet case "case 'xyz': ... break"
case '${1:case}':
	${0:${VISUAL}}
	break;
endsnippet

snippet try "try { ... } catch(e) { ... }"
	try {
		${0:${VISUAL}}
	} catch (${1:e}) {
		${2:/* handle error */}
	}
endsnippet

snippet tryf "try { ... } catch(e) { ... } finally { ... }"
	try {
		${0:${VISUAL}}
	} catch (${1:e}) {
		${2:/* handle error */}
	} finally {
		${3:/* be executed regardless of the try / catch result*/}
	}
endsnippet

snippet throw "throw new Error..."
	throw new Error('${1:error message}')
endsnippet

snippet ret "Return statement"
	return ${0:result};
endsnippet

snippet for "for (...) {...}"
	for (let ${1:i} = 0, ${2:len} = ${3:Things.length}; $1 < $2; $1++) {
		${0:${VISUAL}}
	}
endsnippet

snippet forr "reversed for (...) {...}"
	for (let ${2:i} = ${1:Things.length} - 1; $2 >= 0; $2--) {
		${0:${VISUAL}}
	}
endsnippet

snippet while "(condition) { ... }"
	while (${1:true}) {
		${0:${VISUAL}}
	}
endsnippet

snippet whiletrue "(true) { ... }"
	while (true) {
		${0:${VISUAL}}
	}
endsnippet

snippet dowhile "do { ... } while (condition)"
	do {
		${0:${VISUAL}}
	} while ($1);
endsnippet

snippet forin
	for (let ${1:property} in ${2:objectInstance}) {
		${0:$2[$1]}
	}
endsnippet

snippet forof
for (let ${1:item} of ${2:iterableInstance}) {
	${0}
}
endsnippet

snippet foreach
${1:array}.forEach((${2:item}) => {
	${0}
})
endsnippet

# JSDOC
snippet jsdoc "JSDOC block"
/**
 * ${0:description}
 *
 */
endsnippet

snippet @par "JSDOC param"
@param {${1:type}} ${2:name} ${0:description}
endsnippet

snippet @ret "JSDOC return"
@return {${1:type}} ${0:description}
endsnippet

# Query selector
snippet qs
	${1:document}.querySelector('${0:CSS selector}')
endsnippet

snippet qsa
	${1:document}.querySelectorAll('${0:CSS selector}')
endsnippet

# Debugging
snippet deb
	debugger;
endsnippet

snippet cl "console.log"
	console.log(${0});
endsnippet

snippet cd "console.debug"
	console.debug(${0});
endsnippet

snippet ce "console.error"
	console.error(${0});
endsnippet

snippet cw "console.warn"
	console.warn(${0});
endsnippet

snippet ci "console.info"
	console.info(${0});
endsnippet

